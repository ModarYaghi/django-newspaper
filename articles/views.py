from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.urls import reverse, reverse_lazy
from django.views import View
from django.views.generic import DetailView, FormView, ListView
from django.views.generic.detail import SingleObjectMixin
from django.views.generic.edit import CreateView, DeleteView, UpdateView

from .forms import CommentForm
from .models import Article

# Create your views here.
#


class ArticleCreateView(LoginRequiredMixin, CreateView):
    """
    View to create a new Article.

    This view provides a form to create an article with the specified fields.
    The 'author' field is not included in the form, as it automatically set to
    the currently logged-in user in the form_valid method.
    """

    model = Article
    template_name = "article_new.html"
    fields = (
        "title",
        "body",
        # "author",
    )  # 'author' is set automatically is form_valid.

    def form_valid(self, form):
        """
        Called when a valid form submission is made.

        Automatically sets the 'author' of the Article instance to the logged-in user.
        After setting the author, the parent form_valid method is called to save the object
        and redirect the user.

        :param form: A valid ModelForm instance with cleaned data.
        :type form: django.forms.ModelForm
        :return: An HTTP redirect response after the article is successfully saved.
        :rtype: django.http.HttpResponse
        """

        # Set the article's author to the current user
        form.instance.author = self.request.user
        return super().form_valid(form)


class ArticleListView(LoginRequiredMixin, ListView):
    """
    View to list all Articles.

    Only authenticated users can view the list of articles.
    The view renders the list using the "article_list.html" template.
    """

    model = Article
    template_name = "article_list.html"


class ArticleCommentGetView(DetailView):
    """
    Display the details of an Article alogn with an empty CommentForm.

    This view handles GET request to display an article's details.
    It adds a blank CommentForm to the context so that users can add a comment.
    """

    model = Article
    template_name = "article_detail.html"

    def get_context_data(self, **kwargs):
        """
        Add a CommentForm to the context.

        This method extends the default context with an empty form for creating a new comment.

        :params kwargs: Additional keyword arguments for context data.
        :return: A dictionary representing the template context, including the CommentForm.
        """
        context = super().get_context_data(**kwargs)
        # Add an empty CommentForm to the context so it can be rendered in the template.
        context["form"] = CommentForm()
        return context


class CommentPostView(SingleObjectMixin, FormView):
    """
    Handle post requests to add a comment to an Article.

    This view is responsible for processing the submitted CommentForm.
    It uses SingleObjectMixin to retrieve the associated Article object.
    """

    model = Article
    form_class = CommentForm
    template_name = "article_detail.html"

    def post(self, request, *args, **kwargs):
        """
        Handle the POST request.

        This method sets the Article object before processing the form submission.

        :param requst: The HTTP requst object.
        :param args: Additional positional arguments.
        :param kwargs: Additional keyword arguments.
        :return: The HTTP response generated by the parent FormView post method.
        """
        # Retrieve the Article object that the comment will be associated with.
        self.object = self.get_object()
        return super().post(request, *args, **kwargs)

    def form_valid(self, form):
        """
        Process a valid CommentForm submission.

        This method assigns the article and the author (current user) to the comment,
        saves it, and then delegates the success handling to the parent FormView.
        """
        # Create a new comment instance without saving it immediately.
        comment = form.save(commit=False)
        # Associate the comment with the current Article object.
        comment.article = self.object
        # Set the comment's author to the currently logged-in user.
        comment.author = self.request.user
        # Save the comment to the database.
        comment.save()
        return super().form_valid(form)

    def get_success_url(self):
        """
        Determine the URL to redirect to after successfully processing the comment.

        This method returns the URL for the Article detail view.

        :return: A URL string pointing to the detail view of the associated Article.
        """
        article = self.object
        return reverse("article_detail", kwargs={"pk": article.pk})


class ArticleDetailView(LoginRequiredMixin, View):
    """
    A wrapper view combine Article Detail and Comment handling view.

    This view acts as a dispatcher that delegates GET requests to ArticleCommentGetView
    and POST requests to CommentPostView. This allows the article detail page
    to handle both displaying the article and processing comment submission.
    """

    def get(self, request, *args, **kwargs):
        """
        Handle GET requests by delegating to ArticleCommentGetView.

        :param request: The HTTP request object.
        :param args: Additional positional arguments.
        :param kwargs: Additional keyword arguments.
        :return: An HTTP response with the article details and comment form.
        """
        view = ArticleCommentGetView.as_view()
        return view(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        """
        Hanlde POST requests by delegating to CommentPostView.

        :param request: The HTTP request object.
        :param args: Additional positioanl arguments.
        :param kwargs: Additional keyword arguments.
        :return: An HTTP response resulting from processing the comment form.
        """
        view = CommentPostView.as_view()
        return view(request, *args, **kwargs)


class ArticleUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    """
    View to update/edit an existign Article.

    Provides a form to update the 'title' and 'body' fields of an article.
    Access is restricted using the test_func method to ensure that only the article's
    author or a superuser can edit the article.
    """

    model = Article
    fields = (
        "title",
        "body",
    )
    template_name = "article_edit.html"

    def test_func(self):
        """
        Test whether the current user has permission to edit the article.

        The article can be edited if:
            - The user is a superuser (has all permissions), or
            - The user is the author of the article.

        :return: True if the user is allowed ot edit, False otherwise.
        :rtype: bool
        """
        obj = self.get_object()
        # To let superuser edit content from template directly.
        return self.request.user.is_superuser or obj.author == self.request.user
        #
        # or, the following will resrict every one on the template.
        # return obj.author == self.request.user


class ArticleDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    """
    View to delete an existing Article.

    After deletion, the user is redirected to the article list.
    Access is restricted so that only the article's author or
    a superuser can delete the article.
    """

    model = Article
    template_name = "article_delete.html"
    success_url = reverse_lazy("article_list")

    def test_func(self):
        """
        Test whether the current user has permission to delete the article.

        The article can be deleted if:
            - The user is a superuser, OR
            - The user is the author of the article.

        :return: True if the user is allowed to delete, False otherwise.
        :rtype: bool
        """
        obj = self.get_object()
        # To let superuser edit content from template directly.
        return self.request.user.is_superuser or obj.author == self.request.user
        #
        # or, the following will resrict every one on the template.
        # return obj.author == self.request.user
